\chapter{El Kernel}

Empecemos por decir que lo que aquí se presenta está muy lejos de un sistema operativo completo.

Se priorizó la simplicidad recortando todo lo que estaba de más, reduciendo al mínimo las capacidades del sistema. Por ejemplo la mayoría de los sistemas operativos pueden leer un programa y ejecutarlo. Nuestro querido kernel carece de esa posibilidad.

Lo único que se puede ejecutar actualmente en nuestro sistema es el emulador, y eso sólo porque está embebido en el kernel. Podría verse al emulador como un solo programa standalone, que no necesita ningún sist. operativo para ejecutarse.

Y entonces que necesita como mínimo nuestro emulador? Se muestra, en orden de importancia:
0) Iniciar el sistema y ejecutar el emulador (booteo)
1) Modificar libremente pixeles de la pantalla
2) Detectar pulsaciones del teclado
3) Poder reservar memoria dinámica *explicar que es*
4) Cargar de alguna forma los juegos
5) Ejecutar sonido
6) Escribir en algún medio persistente el estado actual del juego(Guardar la partida)

Pues bien, el kernel tiene que ser capaz de proveer funciones que faciliten cada una de estas tareas. En las siguientes secciones se detallaran cada una de ellas.

\section{Booteo}
Para evitar tener que lidiar con la BIOS y otras interfaces de bajo nivel, se eligió utilizar un bootloader ya existente, GRUB. *poner que carajos es GRUB*. En particular existe un standard llamado multiboot que especifica como estructurar la cabecera\footnote{header, la primera parte} de un kernel para que el mismo pueda ser cargado por GRUB(o por cualquier otro bootloader que implemente multiboot). En esta cabecera se determina que modo se prefiere(texto o consola) y que función va a ser la 1era en ser llamada. A si mismo GRUB se comunica con la BIOS entre otras cosas y recolecta información de la máquina que luego es recibida convenientemente por nuestro kernel. De esta forma al encender la máquina se iniciará GRUB, el mismo va a poder detectar nuestro kernel y lo va a ejecutar.


El problema es que al momento en que GRUB ejecuta el kernel el stack pointer no está inicializado por lo que no es posible que la función inicial sea en C. Debemos comenzar en assembler, inicializar el stack pointer y ahí si pasar e C.